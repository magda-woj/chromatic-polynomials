module Main where

import Control.Monad.Trans.Writer (runWriterT)
import Control.Parallel.Strategies ( Eval, rpar, rseq, runEval, parListChunk, using)
import Control.DeepSeq ( force )
import Control.Monad.Writer
    ( WriterT(runWriterT), MonadIO(liftIO), MonadWriter(tell), forM )
import Control.Monad ( forM )
import Control.Monad.State
    ( State, MonadState(put, get), MonadIO(liftIO), evalState, forM )
import Data.List (delete)
import Data.List.Split (splitOn)
import System.IO ()
import Text.Read (readEither)
import Data.Maybe (mapMaybe)
import Data.Either (partitionEithers)

-- polynomial as a tuple of degree and list of coefficients
type Polynomial = (Int, [Int])

minus :: Polynomial -> Polynomial -> Polynomial
minus (degP, xp) (degQ, xq) =
    let xp' = xp ++ replicate (degQ - degP) 0
        xq' = xq ++ replicate (degP - degQ) 0
        degree = max degP degQ
        coefficients = zipWith (-) xp' xq'
    in (degree, coefficients)

-- show a term based on its coefficient and degree
showTerm :: Int -> Int -> String
showTerm 0 _ = ""
showTerm c 0 = show c
showTerm c 1
  | c == 1 = "x"
  | c == -1 = "-x"
  | otherwise = show c ++ "x"
showTerm c deg = (if c == 1 then "" else if c == -1 then "-" else show c) ++ "x^" ++ show deg

-- formating polynomial to string: slightly cheated, couse here the list of coefficients musn't be in reverse order, like it is everywhere else
formatPoly :: Polynomial -> State Int String
formatPoly (_,[]) = return ""
formatPoly (deg, c:cs) = do
    idx <- get
    let term = showTerm c (deg - idx)
    put (idx + 1)
    rest <- formatPoly (deg, cs)
    if null term then return rest else
        return $ term ++ (if null rest then "" else (if head rest == '-' then "" else "+") ++ rest)

-- display polynomial as string
display :: Polynomial -> String
display (deg, coeffs) = evalState (formatPoly (deg, reverse coeffs)) 0

type Vertex = Int
type Edge = (Vertex, Vertex)
type Graph = ([Vertex], [Edge])

-- read graph from a single line
parseGraph :: String -> Either String Graph
parseGraph line = case readEither line of
    Left err -> Left "Parse error."
    Right graph -> Right graph

-- read readable graphs from file and log any errors
readGraphsFromFile :: FilePath -> WriterT String IO [Graph]
readGraphsFromFile fileName = do
    content <- liftIO $ readFile fileName
    let graphLines = lines content
    parsedGraphs <- forM graphLines $ \line -> do
        case parseGraph line of
            Left err -> do
                tell $ err ++ "\n"
                return []
            Right graph -> do
                return [graph]
    return $ concat parsedGraphs

-- delete all duplicates, we have a simple graph so (u, v) = (v, u)
nub' :: Eq a => [(a, a)] -> [(a,a)]
nub' [] = []
nub' ((x,y):xs) = (x,y) : nub' (filter (\(a,b) -> not ( (a,b) == (x, y) || (a, b) == (y, x))) xs)

-- contract graph over an edge
contract :: Graph -> Edge -> Graph
contract (vertices, edges) (a, b) = (delete b vertices,  newEdges) where
    newEdges = nub' $  map (\(u, v) -> if u == b then (a, v)  else if v == b then (u, a) else (u, v)) (delete (a, b) edges)

-- compute chromatic polynomial using deletion-contraction
chromPolSeq :: Graph -> Polynomial
chromPolSeq (vertices, []) = let deg = length vertices in (deg, replicate deg 0 ++ [1])
chromPolSeq (vertices, e:edges) = chromPolSeq (vertices, edges) `minus` chromPolSeq (contract (vertices, e:edges) e)

-- I was playing with different types of parallel computing, dependent on the size of graphs etc. The priettiest threadscope 
-- pictures are generated by chromPolPar2

-- this is seq computing, but I wanted the same signature as the parallels
chromPolSeq2 :: Graph -> Eval Polynomial
chromPolSeq2 (vertices, []) = let deg = length vertices in return (deg, replicate deg 0 ++ [1])
chromPolSeq2 (vertices, e:edges) =return $ chromPolSeq (vertices, edges) `minus` chromPolSeq (contract (vertices, e:edges) e)

-- every pol is computed in 2 sparks
chromPolPar :: Graph -> Eval Polynomial
chromPolPar (vertices, []) = let deg = length vertices in return (deg, replicate deg 0 ++ [1])
chromPolPar (vertices, e:edges) = do
                                            p <- rpar $ force $ chromPolSeq (vertices, edges)
                                            q <- rpar $ force $ chromPolSeq (contract (vertices, e:edges) e)
                                            rseq p
                                            rseq q
                                            return $ p `minus` q
-- only pols of big graphs are computed in 2 sparks
chromPolPar2 :: Graph -> Eval Polynomial
chromPolPar2 (vertices, []) = let deg = length vertices in return (deg, replicate deg 0 ++ [1])
chromPolPar2 (vertices, e:edges)    | length edges > 20 =  do
                                            p <- rpar $ force $ chromPolSeq (vertices, edges)
                                            q <- rpar $ force $ chromPolSeq (contract (vertices, e:edges) e)
                                            rseq p
                                            rseq q
                                            return $ p `minus` q
                                    | otherwise = return $ chromPolSeq (vertices, edges) `minus` chromPolSeq (contract (vertices, e:edges) e)

-- chunkList n xs = xs split to chanks of length n
chunkList :: Int -> [a] -> [[a]]
chunkList _ [] = []
chunkList n xs =
    let (ys, zs) = splitAt n xs
    in ys : chunkList n zs

-- compute polymomials from the list in parallel chunks
computeChromaticPolynomials :: Int -> [Graph] -> Eval [Polynomial]
computeChromaticPolynomials chunkSize graphs = do
    let chunks = chunkList chunkSize graphs
    let computations = map (runEval.mapM chromPolPar2) chunks --here you can change if you want to compute the polynomials themselves 
        -- in parallel or not, options: chromPolSeq2 (sequential computing), chromPolPar (everyone i par), chromPolPar2 (only big in par)
    parallelComputations <- mapM (rpar.force) computations
    return (concat parallelComputations)

-- originally I wrote this, but my IDE gave me hints and it was working faster, so I changed to the above version, but this 
-- is easier to understand:
-- computeChromaticPolynomials :: Int -> [Graph] -> Eval [Polynomial]
-- computeChromaticPolynomials chunkSize graphs = do
--     let chunks = chunkList chunkSize graphs
--     let computations = map (\chunk -> runEval $ sequence (map chromPolPar2 chunk)) chunks
--     parallelComputations <- sequence (map (rpar . force) computations)
--     return (concat parallelComputations)


main :: IO ()
main = do
    let fileName = "graphs.txt"
    (graphs, log) <- runWriterT $ readGraphsFromFile fileName
    if null graphs then putStrLn "No valid graphs found" else do
        if not (null log) then putStrLn "Warning: not all lines were valid graphs" else putStrLn ""
        putStrLn "Parsed graphs:"
        mapM_ print graphs
        -- -- seq version
        -- let chromPolynomials = map chromPolSeq graphs
        -- putStrLn "\nChromatic polynomials:"
        -- mapM_ (putStrLn . display) chromPolynomials
        -- par version
        let chunkSize = max 1 (length graphs `div` 4)  -- adjust chunk size, you can play with it
        let chromPolynomials = runEval $ computeChromaticPolynomials chunkSize graphs
        putStrLn "\nChromatic polynomials:"
        mapM_ (putStrLn.display) chromPolynomials
